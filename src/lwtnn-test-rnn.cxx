#include "lwtnn/LightweightNeuralNetwork.hh"
#include "lwtnn/Stack.hh"
#include "lwtnn/parse_json.hh"

#include <Eigen/Dense>

#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <cassert>

void usage(const std::string& name) {
  std::cout << "usage: " << name << " <nn config> [<labels> <values>]\n"
    "\n"
    "The <nn config> file should be generated by one of the scripts in\n"
    "`converters/`.\n"
    "\n"
    "Both <labels> and <values> should be whitespace separated.\n"
    "In the case of values, there should be one pattern per line.\n"
    "If the labels and values are omitted generate dummy data.\n";
}

namespace {
  // 2d ramp function, corners are (1, -1, -1, 1), linear
  // interpolation in the grid between
  int run_on_generated(const lwt::JSONConfig& config);
  lwt::VectorMap get_values_vec(const std::vector<lwt::Input>& inputs,
                                size_t n_patterns);
  double ramp(const lwt::Input& in, size_t x, size_t y,
              size_t n_x, size_t n_y);

  int run_on_files(const lwt::JSONConfig& config,
                   const std::string& vars,
                   const std::string& vals);
}

int main(int argc, char* argv[]) {
  if (argc > 4 || argc < 2) {
    usage(argv[0]);
    exit(1);
  }
  // Read in the configuration.
  std::string in_file_name(argv[1]);
  std::ifstream in_file(in_file_name);
  auto config = lwt::parse_json(in_file);

  if ( argc == 4) {
    run_on_files(config, argv[2], argv[3]);
  } else if (argc == 2) {
    run_on_generated(config);
  } else {
    usage(argv[0]);
    exit(1);
  }
  return 0;
}

namespace {

  ////////////////////////////
  // reading from generated //
  ////////////////////////////

  int run_on_generated(const lwt::JSONConfig& config) {
    // Read in the configuration.

    lwt::LightweightRNN rnn(config.inputs, config.layers, config.outputs);
    const auto inputs = get_values_vec(config.inputs, 20);
    auto outs = rnn.reduce(inputs);
    for (const auto& out: outs) {
      std::cout << out.first << " " << out.second << std::endl;
    }
    return 0;
  }

  lwt::VectorMap get_values_vec(const std::vector<lwt::Input>& inputs,
                                size_t n_patterns) {
    lwt::VectorMap out;

    // ramp through the input multiplier
    const size_t total_inputs = inputs.size();
    for (size_t jjj = 0; jjj < n_patterns; jjj++) {
      for (size_t nnn = 0; nnn < total_inputs; nnn++) {
        const auto& input = inputs.at(nnn);
        double ramp_val = ramp(input, nnn, jjj, total_inputs, n_patterns);
        out[input.name].push_back(ramp_val);
      }
    }
    return out;
  }

  // 2d ramp function, see declaration above
  double ramp(const lwt::Input& in, size_t x, size_t y,
              size_t n_x, size_t n_y) {
    assert(x < n_x);
    assert(y < n_y);
    double s_x = 2.0 / (n_x - 1);
    double s_y = 2.0 / (n_y - 1);
    double x_m = ( (n_x == 1) ? 0 : (-1.0 + x * s_x) );
    double y_m = ( (n_y == 1) ? 0 : (-1.0 + y * s_y) );
    return x_m * y_m / in.scale - in.offset;
  }


  ///////////////////////
  // reading from file //
  ///////////////////////

  std::vector<std::string> parse_line(std::string& line) {
    std::stringstream          line_stream(line);
    std::string                cell;

    std::vector<std::string>   result;
    while(line_stream >> cell) {
      result.push_back(cell);
    }
    return result;
  }

  int run_on_files(const lwt::JSONConfig& config,
                   const std::string& vars,
                   const std::string& vals) {
    // initialize the tagger from the configuration
    lwt::LightweightRNN rnn(config.inputs, config.layers, config.outputs);

    // buffer
    std::string val_line;

    // read in input labels and values
    std::ifstream vars_stream( vars );
    std::getline(vars_stream, val_line);
    const auto labels = parse_line(val_line);

    lwt::VectorMap in;

    std::ifstream values( vals );
    while (std::getline(values, val_line)) {
      auto val_strings = parse_line(val_line);
      if (val_strings.size() == 0) continue;
      assert(val_strings.size() == labels.size());
      for (size_t iii = 0; iii < labels.size(); iii++) {
        in[labels.at(iii)].push_back(std::stof(val_strings.at(iii)));
      }
    }
    auto out_vals = rnn.reduce(in);
    // look at the outputs
    for (const auto& out: out_vals) {
      std::cout << out.first << " " << out.second << std::endl;
    }

    return 0;
  }

}
