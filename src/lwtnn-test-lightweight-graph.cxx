// Use example for LightweightGraph, the high level wrapper for Graph

#include "lwtnn/LightweightGraph.hh"
#include "lwtnn/parse_json.hh"
#include "lwtnn/Exceptions.hh"

#include "test_utilities.hh"

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include <iostream>
#include <fstream>
#include <cassert>

namespace {
  lwt::LightweightGraph::SeqNodeMap get_sequences(
    const std::vector<lwt::InputNodeConfig>& config);

  lwt::LightweightGraph::NodeMap get_inputs(std::ifstream& input_file);
  lwt::LightweightGraph::NodeMap get_generated(
    const std::vector<lwt::InputNodeConfig>& config);
  int run_on(const lwt::GraphConfig& config, const std::string& input = "");
}


void usage(const std::string& name) {
  std::cout << "usage: " << name << " <nn config> [inputs file]\n"
    "\n"
    "The <nn config> file should be generated by one of the scripts in\n"
    "`converters/`.\n"
    "\n";
}

int main(int argc, char* argv[]) {
  if (argc > 3 || argc < 2) {
    usage(argv[0]);
    exit(1);
  }
  // Read in the configuration.
  std::string in_file_name(argv[1]);
  std::ifstream in_file(in_file_name);
  auto config = lwt::parse_json_graph(in_file);

  // (maybe) read in an input file
  std::string inputs_file;
  if (argc == 3) {
    inputs_file = argv[2];
  }
  run_on(config, inputs_file);
  return 0;
}
namespace {
  lwt::LightweightGraph::NodeMap get_inputs(std::ifstream& input_file) {
    boost::property_tree::ptree pt;
    boost::property_tree::read_json(input_file, pt);
    lwt::LightweightGraph::NodeMap inputs;
    for (const auto& node: pt) {
      for (const auto& input: node.second) {
        inputs[node.first][input.first] = input.second.get_value<double>();
      }
    }
    return inputs;
  }

  lwt::LightweightGraph::NodeMap get_generated(
    const std::vector<lwt::InputNodeConfig>& config) {
    // Build dummy input patterns from the configuration object. For
    // inputs that take vectors the inner map corresponds to the named
    // input variables for a node. The outer map indexes the nodes by
    // name. The `ramp` function is defined in the `test_utilities`
    // header.
    std::map<std::string, std::map<std::string, double> > in_nodes;
    for (const auto& input: config) {
      const size_t total_inputs = input.variables.size();
      std::map<std::string, double> in_vals;
      for (size_t nnn = 0; nnn < total_inputs; nnn++) {
        const auto& var = input.variables.at(nnn);
        double ramp_val = ramp(var, nnn, total_inputs);
        in_vals[var.name] = ramp_val;
      }
      in_nodes[input.name] = in_vals;
    }
    return in_nodes;
  }


  int run_on(const lwt::GraphConfig& config,
             const std::string& input) {
    using namespace lwt;
    assert(config.outputs.size() > 0);

    // First build the tagger object. For graphs with multiple outputs
    // you must specify the name of the default output by name (thus
    // the second argument here).
    lwt::LightweightGraph tagger(config, config.outputs.begin()->first);

    // The inputs for sequences are defined like those for vectors,
    // but rather than a `double` each variable in the inner map is
    // represented by a vector.
    LightweightGraph::SeqNodeMap seq = get_sequences(config.input_sequences);

    LightweightGraph::NodeMap in_nodes;
    if (input.size() == 0) {
      in_nodes = get_generated(config.inputs);
    } else {
      std::ifstream instream(input);
      in_nodes = get_inputs(instream);
    }

    // Loop over the output names and compute the output for each
    for (const auto& output: config.outputs) {
      try {
        auto out_vals = tagger.scan(in_nodes, seq, output.first);
        std::cout << output.first << ":" << std::endl;
        for (const auto& out: out_vals) {
          std::cout << out.first;
          for (const auto& val: out.second) {
            std::cout << " " << val;
          }
          std::cout << std::endl;
        }
      } catch (lwt::OutputRankException& ex) {
        auto out_vals = tagger.compute(in_nodes, seq, output.first);
        std::cout << output.first << ":" << std::endl;
        for (const auto& out: out_vals) {
          std::cout << out.first << " " << out.second << std::endl;
        }
      }
    }
    return 0;
  }

  lwt::LightweightGraph::SeqNodeMap get_sequences(
    const std::vector<lwt::InputNodeConfig>& config) {
    lwt::LightweightGraph::SeqNodeMap nodes;
    for (const auto& input: config) {
      // see the `test_utilities` header for this function.
      nodes[input.name] = get_values_vec(input.variables, 20);
    }
    return nodes;
  }
}
