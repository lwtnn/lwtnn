// Use example for LightweightGraph, the high level wrapper for Graph

#include "test_utilities.hh"

#include "lwtnn/generic/FastGraph.hh"
#include "lwtnn/parse_json.hh"
#include "lwtnn/Exceptions.hh"

#include <Eigen/Dense>

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include <iostream>
#include <fstream>
#include <cassert>

namespace {
  lwt::order_t get_input_names(const std::vector<lwt::InputNodeConfig>& cfg);
  template<typename T>
  int run_on(const lwt::GraphConfig& config, const std::string& = "");
  template<typename T>
  lwt::VectorX<T> get_input_vec(const std::vector<lwt::Input>& inputs);
  template<typename T>
  lwt::MatrixX<T> get_input_mat(const std::vector<lwt::Input>& inputs,
                                std::size_t n_patterns);
}


void usage(const std::string& name) {
  std::cout << "usage: " << name << " <nn config>\n"
    "\n"
    "The <nn config> file should be generated by one of the scripts in\n"
    "`converters/`.\n"
    "\n";
}

int main(int argc, char* argv[]) {
  if (argc != 2) {
    usage(argv[0]);
    exit(1);
  }
  // Read in the configuration.
  std::string in_file_name(argv[1]);
  std::ifstream in_file(in_file_name);
  auto config = lwt::parse_json_graph(in_file);

  run_on<float>(config, ", type float");
  run_on<double>(config, ", type double");
  return 0;
}
namespace {

  template<typename T>
  int run_on(const lwt::GraphConfig& config,
             const std::string& more_info) {
    using namespace lwt;
    assert(config.outputs.size() > 0);

    // First build the tagger object.
    lwt::InputOrder order;
    order.scalar = get_input_names(config.inputs);
    order.sequence = get_input_names(config.input_sequences);
    lwt::generic::FastGraph<T> tagger(config, order);

    std::vector<lwt::VectorX<T>> scalars;
    for (const auto& scalar: config.inputs) {
      scalars.push_back(get_input_vec<T>(scalar.variables));
    }
    std::vector<lwt::MatrixX<T>> sequences;
    for (const auto& seq: config.input_sequences) {
      sequences.push_back(get_input_mat<T>(seq.variables,20));
    }
    std::cout << "running with " << order.scalar.size() << " scalars, and "
              << order.sequence.size() << " sequences" << more_info
              << std::endl;
    lwt::VectorX<T> output = tagger.compute(scalars, sequences);
    for (int iii = 0; iii < output.size(); iii++) {
      if (iii > 0) std::cout << ", ";
      std::cout << output(iii);
    }
    std::cout << std::endl;

    return 0;
  }

  lwt::order_t get_input_names(const std::vector<lwt::InputNodeConfig>& cfg) {
    lwt::order_t out;
    for (const auto& node: cfg) {
      std::vector<std::string> names;
      for (const auto& input: node.variables) {
        names.emplace_back(input.name);
      }
      out.emplace_back(node.name, names);
    }
    return out;
  }

  template<typename T>
  lwt::VectorX<T> get_input_vec(const std::vector<lwt::Input>& inputs) {
    std::size_t n_inputs = inputs.size();
    lwt::VectorX<T> out(n_inputs);
    for (std::size_t nnn = 0; nnn < n_inputs; nnn++) {
      out(nnn) = ramp(inputs.at(nnn), nnn, n_inputs);
    }
    return out;
  }
  template<typename T>
  lwt::MatrixX<T> get_input_mat(const std::vector<lwt::Input>& inputs,
                                std::size_t n_patterns) {
    std::size_t n_inputs = inputs.size();
    lwt::MatrixX<T> out(n_inputs, n_patterns);
    for (std::size_t nnn = 0; nnn < n_inputs; nnn++) {
      const auto& input = inputs.at(nnn);
      for (std::size_t jjj = 0; jjj < n_patterns; jjj++) {
        out(nnn,jjj) = ramp(input, nnn, jjj, n_inputs, n_patterns);
      }
    }
    return out;
  }

}
